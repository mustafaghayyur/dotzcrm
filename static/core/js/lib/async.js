import merge from 'lodash/merge';
import helper from "../helpers/main";

/**
 * This class handles one fetch ooperation for one DOM element. The supplied
 * request definition is fetched, and any resultant response from the API
 * resource is redenred into the DOM element who's ID is supplied.
 * 
 * The mapper is critical to rendering the response. Please see examples of 
 * implementation to learn more.
 * 
 * To define HTTP operations for multiple elements, call Fetcher for each
 * DOM element seperately.
 * 
 * @param {*} request - use defineRequest() to attain this object
 * @param {*} containerId - id of HTML DOM element in which response will be rendered
 * @param {*} mapper - object that defines a collection of dom elements to map to api response
 * @param {*} callbackFunction - in complicated cases, response can be rendered with your own callback function
 */
export function Fetcher(request, containerId, mapper = {}, callbackFunction = null) {
    let spinner = null; // holds spinner element retrieved/generated by getSpinner()

    /**
     * Performs the actual HTTP request.
     * Handles container and spinner states as well (partially).
     * @param {*} request - Request object
     */
    async function fetchResource(reqObj) {
        spinner = getSpinner();
        let container = document.getElementById(containerId);
        try {
            let response = await fetch(reqObj);
            
            if (!response.ok) {
                const errorResponse = await response.json();
                let msgHtml = '';
                let errorHtml = '';
                if (Object.hasOwn(errorResponse, 'errors') === true) {
                    errorHtml = '<div class="small">' + helper.forms.escapeHtml(JSON.stringify(errorResponse.errors)) + '</div>';
                    if (Object.hasOwn(errorResponse, 'messages') === true) {
                        msgHtml = '<div>' + helper.forms.escapeHtml(JSON.stringify(errorResponse.messages)) + '</div>';
                    }
                }
                const errHeading = '<div class="lead">Error loading: ' + helper.forms.escapeHtml(response.status + ' ' + response.statusText) + '</div>';
                throw new Error(errHeading + msgHtml + errorHtml);
            }

            if (typeof callbackFunction === 'function' && response.status === 204) {
                return callbackFunction(response, containerId);
            }

            let contentType = response.headers.get('content-type') || '';
            
            if (contentType.includes('application/json')) {
                let data = await response.json();
                if (Object.hasOwn(data, 'results') === true) {
                    renderResponse(data.results);
                    return true;
                }
            } else {
                let text = await response.text();
                container.innerHTML = '<pre>' + helper.forms.escapeHtml(text) + '</pre>';
            }
        } catch (err) {
            container.innerHTML = '<div class="alert alert-danger">' + err.message + '</div>';
        } finally {
            if (container !== null && container instanceof HTMLElement && container.contains(spinner)) {
                spinner.classList.add('d-none');
            }
        }
    }

    function renderResponse(resultSet) {
        const container = document.getElementById(containerId);
        
        if (typeof callbackFunction === 'function') {
            return callbackFunction(resultSet, containerId);
        }

        // No callback provided, setup standard response
        if (Array.isArray(resultSet)) {
            const ul = document.createElement('ul');
            ul.className = 'list-group';
            
            resultSet.forEach(item => {
                let li = document.createElement('li');
                li.className = 'list-group-item';
                li.appendChild(generateRecordDom(item, 'div'));
                ul.appendChild(li);
            });

            container.innerHTML = '';
            container.appendChild(ul);
        } else {
            container.innerHTML = '<pre>' + helper.forms.escapeHtml(JSON.stringify(resultSet, null, 2)) + '</pre>';
        }
    }

    /**
     * Recursive function. Maps out single record from the response' Array.
     * @param {*} record - single record from respnse.resultArray()
     * @param {*} wrapperTag - what tag this record should be wrapped in.
     * @param {*} level - should not be touched, recursive operation
     * @param {*} newMapper - should not be touched, recursive operation
     * @returns 
     */
    function generateRecordDom(record, wrapperTag, level = 0, newMapper = null) {
        dom = document.createElement(wrapperTag);
        dom.className = 'itm-record-lvl-' + level;
        i = 0;

        if (newMapper !== null) {
            internalMapper = newMapper;
        } else {
            internalMapper = mapper
        } 

        for (const [key, value] of Object.entries(internalMapper)) {
            if (key in record) {
                if (value instanceof HTMLElement) {
                    let el = value;
                    el.innerHTML = helper.forms.escapeHtml(String(record[key]));
                    dom.appendChild(el);
                    i++;
                    continue;
                }
                
                if (typeof value === 'object' && !(value instanceof HTMLElement)) {
                    child = generateRecordDom(record[key], wrapperTag, (i + 1), value);
                    if (child instanceof HTMLElement) {
                        dom.appendChild(child);
                        i++;
                        continue;
                    }
                }
                console.log('generateRecordDom() - level: '+ level +'; could not map key=' + key + ' to record key despite match. Problem with mapper.');
            } else {
                console.log('generateRecordDom() - level: '+ level +'; could not find match for record key=' + key + ', skipping.');
            }
        }

        if (i === 0) {
            console.log('generateRecordDom() - level: '+ level +'; mapper could not be processed, aborting record rendition');
        }
        return dom;
    }

    /**
     * Generate, set and return spinner element inside container.
     */
    function getSpinner() {
        if (spinner !== null && (spinner instanceof HTMLElement)) {
            return spinner;
        }

        let id = containerId + 'Spinner'
        let container = document.getElementById(containerId)
        if (container !== null && (container instanceof HTMLElement)) {
            container.innerHTML = '<div class="spinner-border text-primary" role="status" id=' + id +'><span class="visually-hidden">Loading...</span></div>';
        }

        spinner = document.getElementById(id)

        if (spinner instanceof HTMLElement) {
            return spinner;
        }

        return null;
    }

    /**
     * Implementation of Fetcher...
     * see console logs for errors found during rendering of response...
     */
    fetchResource(request);
}

/**
 * Use this function to aquire Request object to supply to Fetcher().
 * Helps form a proper request definition object
 */
export function defineRequest(urlKey, urlParams = {}, options = {}) {
    const urlTemplate = selectUrlTemplate(urlKey);
    let url = generateUrl(urlTemplate, urlParams);
    
    const defaults = {
        method: 'GET',
        headers: {
            'Content-Type': 'application/json',
            'Authorization': ' Bearer ' + getAccessToken(),
        },
    };
    const finalOptions = merge(defaults, options);
    return new Request(url, finalOptions);
}

function selectUrlTemplate(urlKey) {
    if (helper.generic.checkVariableType(urlKey) !== 'string') {
        throw new Error('defineRequest() - urlKey must be a string in format "app.key"');
    }
    parts = urlKey.split('.');
    if (parts.length > 1) {
        throw new Error('defineRequest() - urlKey must be in format "app.key"');
    }
    return projectUrls[parts[0]][parts[1]];
}

function generateUrl(template, params) {
    if (helper.generic.checkVariableType(params) === 'string') {
        params = {
            input1: params
        };
    }
    let inputs = RegExp('({input[0-9]+})', 'g');
    return template.replace(inputs, (match, input) => {
        if (input in params) {
            return encodeURIComponent(params[input]);
        } else {
            throw new Error('generateUrl() - missing url parameter: ' + input);
        }
    });
}

function getAccessToken() {
    // retrieves time of last token refresh
    const lastAccess = tokenLastRefreshed();

    // check if token is older than 60 minutes
    if (lastAccess - Date.now() > 3600000) {
        // refresh token
        return refreshToken();
    } else {
        return getCurrentAccessToken();
    }
}

function refreshToken() {
    const refreshToken = localStorage.getItem('refresh_token');
    if (refreshToken === null) {
        throw new Error('refreshToken() - no refresh token found in localStorage');
    }

    const request = new Request(projectUrls.auth.refresh, {
        method: 'POST',
        headers: {
            'Content-Type': 'application/json',
        },
        body: JSON.stringify({ refresh: refreshToken }),
    });

    Fetcher(request, 'tokenRefreshContainer', {}, (response) => {
        if (response.status === 200) {
            return response.json().then(data => {
                localStorage.setItem('access_token', data.access);
                localStorage.setItem('refresh_token', data.refresh);
                localStorage.setItem('token_last_refreshed', Date.now().toString());
                return data.access;
            });
        } else {
            throw new Error('refreshToken() - failed to refresh token, status: ' + response.status);
        }
    });
}
/**
 * All urls for CRM + PM Software
 */
const projectUrls = {
    auth: {
        login: '/accounts/token/',
        refresh: '/accounts/token/refresh/',
    },
    task: {
        crud: '/rest/tasks/crud/{input1}/',
        list: '/rest/tasks/{input1}/',
        comment_crud: '/rest/tasks/comments/crud/{input1}/',
        comment_list: '/rest/tasks/comments/',
        watcher_crud: '/rest/tasks/watchers/crud/{input1}/',
        watcher_list: '/rest/tasks/watchers/{input1}/',
    }
}

/**
 * localStorage.setItem(key, value): Stores a key-value pair.
 * localStorage.getItem(key): Retrieves a value by its key.
 * localStorage.removeItem(key): Removes a specific item by its key.
 * localStorage.clear(): Clears all data stored for the current domain. 
 * 
 * OR 
 * 
 * http cookie with HttpOnly, Secure, and SameSite flags
 */