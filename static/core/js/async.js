import _ from 'lodash';

/**
 * This class handles one fetch ooperation for one DOM element. The supplied
 * request definition is fetched, and any resultant response from the API
 * resource is redenred into the DOM element who's ID is supplied.
 * 
 * The mapper is critical to rendering the response. Please see examples of 
 * implementation to learn more.
 * 
 * To define HTTP operations for multiple elements, call Fetcher for each
 * DOM element seperately.
 * 
 * @param {*} request - use defineRequest() to attain this object
 * @param {*} containerId - id of HTML DOM element in which response will be rendered
 * @param {*} mapper - object that defines a collection of dom elements to map to api response
 * @param {*} callbackFunction - in complicated cases, response can be rendered with your own callback function
 */
export function Fetcher(request, containerId, mapper = {}, callbackFunction = null) {
    let spinner = null; // holds spinner element retrieved/generated by getSpinner()

    /**
     * Performs the actual HTTP request.
     * Handles container and spinner states as well (partially).
     * @param {*} request - Request object
     */
    async function fetchResource(reqObj) {
        spinner = getSpinner()
        let container = document.getElementById(containerId)
        try {
            let response = await fetch(reqObj);
            
            if (!response.ok) {
                throw new Error(response.status + ' ' + response.statusText);
            }

            let contentType = response.headers.get('content-type') || '';
            
            if (contentType.includes('application/json')) {
                let data = await response.json();
                renderResponse(data.results);
            } else {
                let text = await response.text();
                container.innerHTML = '<pre>' + escapeHtml(text) + '</pre>';
            }
        } catch (err) {
            container.innerHTML = '<div class="alert alert-danger">Error loading: ' + escapeHtml(err.message) + '</div>';
        } finally {
            spinner.classList.add('d-none');
        }
    }

    function renderResponse(resultSet) {
        const container = document.getElementById(containerId);
        
        if (typeof callbackFunction === 'function') {
            return callbackFunction(resultSet, containerId);
        }

        // No callback provided, setup standard response
        if (Array.isArray(resultSet)) {
            const ul = document.createElement('ul');
            ul.className = 'list-group';
            
            resultSet.forEach(item => {
                let li = document.createElement('li');
                li.className = 'list-group-item';
                li.appendChild(generateRecordDom(item, 'div'));
                ul.appendChild(li);
            });

            container.innerHTML = '';
            container.appendChild(ul);
        } else {
            container.innerHTML = '<pre>' + escapeHtml(JSON.stringify(resultSet, null, 2)) + '</pre>';
        }
    }

    /**
     * Recursive function. Maps out single record from the response' Array.
     * @param {*} record - single record from respnse.resultArray()
     * @param {*} wrapperTag - what tag this record should be wrapped in.
     * @param {*} level - should not be touched, recursive operation
     * @param {*} newMapper - should not be touched, recursive operation
     * @returns 
     */
    function generateRecordDom(record, wrapperTag, level = 0, newMapper = null) {
        dom = document.createElement(wrapperTag);
        dom.className = 'itm-record-lvl-' + level;
        i = 0;

        if (newMapper !== null) {
            internalMapper = newMapper;
        } else {
            internalMapper = mapper
        } 

        for (const [key, value] of Object.entries(internalMapper)) {
            if (key in record) {
                if (value instanceof HTMLElement) {
                    let el = value;
                    el.innerHTML = escapeHtml(String(record[key]));
                    dom.appendChild(el);
                    i++;
                    continue;
                }
                
                if (typeof value === 'object' && !value instanceof HTMLElement) {
                    child = generateRecordDom(record[key], wrapperTag, (i + 1), value);
                    if (child instanceof HTMLElement) {
                        dom.appendChild(child);
                        i++;
                        continue;
                    }
                }
                console.log('generateRecordDom() - level: '+ level +'; could not map key=' + key + ' to record key despite match. Problem with mapper.');
            } else {
                console.log('generateRecordDom() - level: '+ level +'; could not find match for record key=' + key + ', skipping.');
            }
        }

        if (i === 0) {
            console.log('generateRecordDom() - level: '+ level +'; mapper could not be processed, aborting record rendition');
        }
        return dom;
    }

    /**
     * helper function for safe rendering of user-supplied code.
     * @todo - see if better escape operations are needed.
     * @param {*} str - string to escape
     */
    function escapeHtml(str) {
        return String(str).replace(/[&<>"]+/g, s => ({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;'}[s]));
    }

    /**
     * Generate, set and return spinner element inside container.
     */
    function getSpinner() {
        if (spinner !== null && spinner instanceof HTMLElement) {
            return spinner;
        }

        let id = containerId + 'Spinner'
        let container = document.getElementById(containerId)
        if (container !== null && container instanceof HTMLElement) {
            container.innerHTML = '<div class="spinner-border text-primary" role="status" id=' + id +'><span class="visually-hidden">Loading...</span></div>';
        }

        spinner = document.getElementById(id)

        if (spinner instanceof HTMLElement) {
            return spinner;
        }

        return null;
    }

    /**
     * Implementation of Fetcher...
     * see console logs for errors found during rendering of response...
     */
    fetchResource(request);
}

/**
 * Use this function to aquire Request object to supply to Fetcher().
 * Helps form a proper request definition object
 */
export function defineRequest(url, options = {}) {
    const defaults = {
        method: 'GET',
        headers: { 'Content-Type': 'application/json' },
    };
    const finalOptions = merge(defaults, options);
    return new Request(url, finalOptions);
}